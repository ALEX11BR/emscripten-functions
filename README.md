# Crates for emscripten targets in rust

This project contains 2 crates with functions (and types too) to help rust development for emscripten targets.

## The crates

- `emscripten-sys` - Raw bindgen-generated rust bindings to emscriptenâ€™s system functions.
- `emscripten-functions` - Various emscripten system functions that make programming in rust for emscripten targets easier.

## Why emscripten for rust

If you want to write web apps in rust, the `wasm32-unknown-unknown` target is the top choice, with a quite mature ecosystem of functions that interact with the web ecosystem.
That being said, if your project has parts or libraries written in C or C++, then the `wasm32-unknown-unknown` target doesn't work anymore.
Also, you might be interested in using [asm.js](https://en.wikipedia.org/wiki/Asm.js) instead of [WASM](https://en.wikipedia.org/wiki/WebAssembly).

Thankfully, there is an alternative: `wasm32-unknown-emscripten` (and `asmjs-unknown-emscripten` too).
Emscripten provides a ready-to-use libc for web apps, and a few other popular C libraries, like SDL.
Using the 2 crates, interacting with the web environment of emscripten becomes easier.

## Some tips

### Functions that can be triggered dynamically
- Make a function with `#[no_mangle] pub extern "C" fn function_name ...` (they can accept and return integers, floats,  C-style strings or arrays of byte-sized numbers),
- add `-sEXPORTED_RUNTIME_METHODS=ccall,cwrap` and `-sEXPORTED_FUNCTIONS=_function_name,...` (add a preceding underscore to your functions' names and separate them with commas) as link arguments,

... and you can call your functions using the [ccall/cwrap](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code-ccall-cwrap) emscripten javascript functions.

#### Example

The rust part:
```rust
use std::ffi::{CStr, CString};
use std::os::raw::c_char;

#[no_mangle]
pub extern "C" fn concat_str_int(s: *const c_char, i: i32) -> *const c_char {
    // s (char pointer) => string (rust &str)
    let string = if s.is_null() {
        ""
    } else {
        (unsafe { CStr::from_ptr(s) }).to_str().unwrap()
    };

    let result = format!("{}_{}", string, i);

    // result (rust String) => return value (char pointer)
    let result_cstring = CString::new(result.as_bytes()).unwrap();
    let result_ptr = result_cstring.as_ptr();
    std::mem::forget(result_cstring);
    return result_ptr as *const _;
}
```

The javascript part:
```js
// `out.js`` is the file generated by emscripten, it should be named after your project.
// If you don't work with modules, you can put a <script src="out.js"></script> before your script.
import Module from "./out.js"

let concat_str_int = Module.cwrap("concat_str_int", "string", ["string", "number"])

let button = document.querySelector("button")
button.onclick = () => {
    document.title = concat_str_int(document.title, Date.now())
}
```

### Run javascript from rust

Using the [`emscripten_functions::emscripten::run_script`](emscripten-functions/src/emscripten.rs) family of functions you can run the javascript you need in your web app.

#### Example
```rust
// The `.escape_unicode()` method makes it safe to pass untrusted user input.
run_script(
    format!(
        r##"
            document.querySelector("#this-is-secure").innerHTML = "{}"
        "##, 
        "untrusted user input".escape_unicode()
    )
);
```

### Main loop control

If you need to run a loop function over and over, emscripten has its own main loop managing system.
Using the [`emscripten_functions::emscripten::set_main_loop`](emscripten-functions/src/emscripten.rs) and [`emscripten_functions::emscripten::set_main_loop_with_arg`](emscripten-functions/src/emscripten.rs) functions you can run your rust functions as main loops, with full control over the main loop running parameters.
